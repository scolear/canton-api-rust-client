/*
 * JSON Ledger API HTTP endpoints
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.3.0-SNAPSHOT
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for typed errors of method [`delete_v2_idps_idp_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteV2IdpsIdpIdError {
    Status400(String),
    DefaultResponse(models::JsCantonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_v2_users_user_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteV2UsersUserIdError {
    Status400(String),
    DefaultResponse(models::JsCantonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_v2_idps`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetV2IdpsError {
    Status400(String),
    DefaultResponse(models::JsCantonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_v2_idps_idp_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetV2IdpsIdpIdError {
    Status400(String),
    DefaultResponse(models::JsCantonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_v2_interactive_submission_preferred_package_version`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetV2InteractiveSubmissionPreferredPackageVersionError {
    Status400(String),
    DefaultResponse(models::JsCantonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_v2_packages`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetV2PackagesError {
    Status400(String),
    DefaultResponse(models::JsCantonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_v2_packages_package_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetV2PackagesPackageIdError {
    Status400(String),
    DefaultResponse(models::JsCantonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_v2_packages_package_id_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetV2PackagesPackageIdStatusError {
    Status400(String),
    DefaultResponse(models::JsCantonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_v2_parties`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetV2PartiesError {
    Status400(String),
    DefaultResponse(models::JsCantonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_v2_parties_participant_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetV2PartiesParticipantIdError {
    Status400(String),
    DefaultResponse(models::JsCantonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_v2_parties_party`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetV2PartiesPartyError {
    Status400(String),
    DefaultResponse(models::JsCantonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_v2_state_connected_synchronizers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetV2StateConnectedSynchronizersError {
    Status400(String),
    DefaultResponse(models::JsCantonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_v2_state_latest_pruned_offsets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetV2StateLatestPrunedOffsetsError {
    Status400(String),
    DefaultResponse(models::JsCantonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_v2_state_ledger_end`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetV2StateLedgerEndError {
    Status400(String),
    DefaultResponse(models::JsCantonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_v2_updates_transaction_tree_by_id_update_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetV2UpdatesTransactionTreeByIdUpdateIdError {
    Status400(String),
    DefaultResponse(models::JsCantonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_v2_updates_transaction_tree_by_offset_offset`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetV2UpdatesTransactionTreeByOffsetOffsetError {
    Status400(String),
    DefaultResponse(models::JsCantonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_v2_users`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetV2UsersError {
    Status400(String),
    DefaultResponse(models::JsCantonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_v2_users_user_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetV2UsersUserIdError {
    Status400(String),
    DefaultResponse(models::JsCantonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_v2_users_user_id_rights`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetV2UsersUserIdRightsError {
    Status400(String),
    DefaultResponse(models::JsCantonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_v2_version`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetV2VersionError {
    Status400(String),
    DefaultResponse(models::JsCantonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_v2_idps_idp_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchV2IdpsIdpIdError {
    Status400(String),
    DefaultResponse(models::JsCantonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_v2_parties_party`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchV2PartiesPartyError {
    Status400(String),
    DefaultResponse(models::JsCantonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_v2_users_user_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchV2UsersUserIdError {
    Status400(String),
    DefaultResponse(models::JsCantonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_v2_users_user_id_identity_provider_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchV2UsersUserIdIdentityProviderIdError {
    Status400(String),
    DefaultResponse(models::JsCantonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_v2_users_user_id_rights`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchV2UsersUserIdRightsError {
    Status400(String),
    DefaultResponse(models::JsCantonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_v2_commands_async_submit`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostV2CommandsAsyncSubmitError {
    Status400(String),
    DefaultResponse(models::JsCantonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_v2_commands_async_submit_reassignment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostV2CommandsAsyncSubmitReassignmentError {
    Status400(String),
    DefaultResponse(models::JsCantonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_v2_commands_completions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostV2CommandsCompletionsError {
    Status400(String),
    DefaultResponse(models::JsCantonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_v2_commands_submit_and_wait`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostV2CommandsSubmitAndWaitError {
    Status400(String),
    DefaultResponse(models::JsCantonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_v2_commands_submit_and_wait_for_reassignment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostV2CommandsSubmitAndWaitForReassignmentError {
    Status400(String),
    DefaultResponse(models::JsCantonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_v2_commands_submit_and_wait_for_transaction`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostV2CommandsSubmitAndWaitForTransactionError {
    Status400(String),
    DefaultResponse(models::JsCantonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_v2_commands_submit_and_wait_for_transaction_tree`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostV2CommandsSubmitAndWaitForTransactionTreeError {
    Status400(String),
    DefaultResponse(models::JsCantonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_v2_events_events_by_contract_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostV2EventsEventsByContractIdError {
    Status400(String),
    DefaultResponse(models::JsCantonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_v2_idps`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostV2IdpsError {
    Status400(String),
    DefaultResponse(models::JsCantonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_v2_interactive_submission_execute`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostV2InteractiveSubmissionExecuteError {
    Status400(String),
    DefaultResponse(models::JsCantonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_v2_interactive_submission_prepare`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostV2InteractiveSubmissionPrepareError {
    Status400(String),
    DefaultResponse(models::JsCantonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_v2_packages`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostV2PackagesError {
    Status400(String),
    DefaultResponse(models::JsCantonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_v2_parties`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostV2PartiesError {
    Status400(String),
    DefaultResponse(models::JsCantonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_v2_state_active_contracts`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostV2StateActiveContractsError {
    Status400(String),
    DefaultResponse(models::JsCantonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_v2_updates_flats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostV2UpdatesFlatsError {
    Status400(String),
    DefaultResponse(models::JsCantonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_v2_updates_transaction_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostV2UpdatesTransactionByIdError {
    Status400(String),
    DefaultResponse(models::JsCantonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_v2_updates_transaction_by_offset`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostV2UpdatesTransactionByOffsetError {
    Status400(String),
    DefaultResponse(models::JsCantonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_v2_updates_trees`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostV2UpdatesTreesError {
    Status400(String),
    DefaultResponse(models::JsCantonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_v2_updates_update_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostV2UpdatesUpdateByIdError {
    Status400(String),
    DefaultResponse(models::JsCantonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_v2_updates_update_by_offset`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostV2UpdatesUpdateByOffsetError {
    Status400(String),
    DefaultResponse(models::JsCantonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_v2_users`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostV2UsersError {
    Status400(String),
    DefaultResponse(models::JsCantonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_v2_users_user_id_rights`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostV2UsersUserIdRightsError {
    Status400(String),
    DefaultResponse(models::JsCantonError),
    UnknownValue(serde_json::Value),
}

/// Delete identity provider config
pub async fn delete_v2_idps_idp_id(
    configuration: &configuration::Configuration,
    idp_id: &str,
) -> Result<serde_json::Value, Error<DeleteV2IdpsIdpIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_idp_id = idp_id;

    let uri_str = format!(
        "{}/v2/idps/{idp_id}",
        configuration.base_path,
        idp_id = crate::apis::urlencode(p_idp_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Sec-WebSocket-Protocol", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteV2IdpsIdpIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Delete user.
pub async fn delete_v2_users_user_id(
    configuration: &configuration::Configuration,
    user_id: &str,
) -> Result<serde_json::Value, Error<DeleteV2UsersUserIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_user_id = user_id;

    let uri_str = format!(
        "{}/v2/users/{user_id}",
        configuration.base_path,
        user_id = crate::apis::urlencode(p_user_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Sec-WebSocket-Protocol", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteV2UsersUserIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// List all identity provider configs
pub async fn get_v2_idps(
    configuration: &configuration::Configuration,
) -> Result<models::ListIdentityProviderConfigsResponse, Error<GetV2IdpsError>> {
    let uri_str = format!("{}/v2/idps", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Sec-WebSocket-Protocol", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListIdentityProviderConfigsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListIdentityProviderConfigsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetV2IdpsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get identity provider config
pub async fn get_v2_idps_idp_id(
    configuration: &configuration::Configuration,
    idp_id: &str,
) -> Result<models::GetIdentityProviderConfigResponse, Error<GetV2IdpsIdpIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_idp_id = idp_id;

    let uri_str = format!(
        "{}/v2/idps/{idp_id}",
        configuration.base_path,
        idp_id = crate::apis::urlencode(p_idp_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Sec-WebSocket-Protocol", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetIdentityProviderConfigResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetIdentityProviderConfigResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetV2IdpsIdpIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get the preferred package version for constructing a command submission
pub async fn get_v2_interactive_submission_preferred_package_version(
    configuration: &configuration::Configuration,
    package_name: &str,
    parties: Option<Vec<String>>,
    vetting_valid_at: Option<String>,
    synchronizer_id: Option<&str>,
) -> Result<
    models::GetPreferredPackageVersionResponse,
    Error<GetV2InteractiveSubmissionPreferredPackageVersionError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_package_name = package_name;
    let p_parties = parties;
    let p_vetting_valid_at = vetting_valid_at;
    let p_synchronizer_id = synchronizer_id;

    let uri_str = format!(
        "{}/v2/interactive-submission/preferred-package-version",
        configuration.base_path
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_parties {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("parties".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "parties",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    req_builder = req_builder.query(&[("package-name", &p_package_name.to_string())]);
    if let Some(ref param_value) = p_vetting_valid_at {
        req_builder = req_builder.query(&[("vetting_valid_at", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_synchronizer_id {
        req_builder = req_builder.query(&[("synchronizer-id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Sec-WebSocket-Protocol", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetPreferredPackageVersionResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetPreferredPackageVersionResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetV2InteractiveSubmissionPreferredPackageVersionError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// List all packages uploaded on the participant node
pub async fn get_v2_packages(
    configuration: &configuration::Configuration,
) -> Result<models::ListPackagesResponse, Error<GetV2PackagesError>> {
    let uri_str = format!("{}/v2/packages", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Sec-WebSocket-Protocol", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListPackagesResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListPackagesResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetV2PackagesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Download the package for the requested package-id
pub async fn get_v2_packages_package_id(
    configuration: &configuration::Configuration,
    package_id: &str,
) -> Result<reqwest::Response, Error<GetV2PackagesPackageIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_package_id = package_id;

    let uri_str = format!(
        "{}/v2/packages/{package_id}",
        configuration.base_path,
        package_id = crate::apis::urlencode(p_package_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Sec-WebSocket-Protocol", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(resp)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetV2PackagesPackageIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get package status
pub async fn get_v2_packages_package_id_status(
    configuration: &configuration::Configuration,
    package_id: &str,
) -> Result<models::GetPackageStatusResponse, Error<GetV2PackagesPackageIdStatusError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_package_id = package_id;

    let uri_str = format!(
        "{}/v2/packages/{package_id}/status",
        configuration.base_path,
        package_id = crate::apis::urlencode(p_package_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Sec-WebSocket-Protocol", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetPackageStatusResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetPackageStatusResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetV2PackagesPackageIdStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// List all known parties.
pub async fn get_v2_parties(
    configuration: &configuration::Configuration,
    page_size: Option<i32>,
    page_token: Option<&str>,
) -> Result<models::ListKnownPartiesResponse, Error<GetV2PartiesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_page_size = page_size;
    let p_page_token = page_token;

    let uri_str = format!("{}/v2/parties", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page_size {
        req_builder = req_builder.query(&[("pageSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page_token {
        req_builder = req_builder.query(&[("pageToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Sec-WebSocket-Protocol", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListKnownPartiesResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListKnownPartiesResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetV2PartiesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get participant id
pub async fn get_v2_parties_participant_id(
    configuration: &configuration::Configuration,
) -> Result<models::GetParticipantIdResponse, Error<GetV2PartiesParticipantIdError>> {
    let uri_str = format!("{}/v2/parties/participant-id", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Sec-WebSocket-Protocol", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetParticipantIdResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetParticipantIdResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetV2PartiesParticipantIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get party details
pub async fn get_v2_parties_party(
    configuration: &configuration::Configuration,
    party: &str,
    identity_provider_id: Option<&str>,
    parties: Option<Vec<String>>,
) -> Result<models::GetPartiesResponse, Error<GetV2PartiesPartyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_party = party;
    let p_identity_provider_id = identity_provider_id;
    let p_parties = parties;

    let uri_str = format!(
        "{}/v2/parties/{party}",
        configuration.base_path,
        party = crate::apis::urlencode(p_party)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_identity_provider_id {
        req_builder = req_builder.query(&[("identity-provider-id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_parties {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("parties".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "parties",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Sec-WebSocket-Protocol", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetPartiesResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetPartiesResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetV2PartiesPartyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get connected synchronizers
pub async fn get_v2_state_connected_synchronizers(
    configuration: &configuration::Configuration,
    party: &str,
    participant_id: Option<&str>,
) -> Result<models::GetConnectedSynchronizersResponse, Error<GetV2StateConnectedSynchronizersError>>
{
    // add a prefix to parameters to efficiently prevent name collisions
    let p_party = party;
    let p_participant_id = participant_id;

    let uri_str = format!(
        "{}/v2/state/connected-synchronizers",
        configuration.base_path
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("party", &p_party.to_string())]);
    if let Some(ref param_value) = p_participant_id {
        req_builder = req_builder.query(&[("participantId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Sec-WebSocket-Protocol", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetConnectedSynchronizersResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetConnectedSynchronizersResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetV2StateConnectedSynchronizersError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get latest pruned offsets
pub async fn get_v2_state_latest_pruned_offsets(
    configuration: &configuration::Configuration,
) -> Result<models::GetLatestPrunedOffsetsResponse, Error<GetV2StateLatestPrunedOffsetsError>> {
    let uri_str = format!("{}/v2/state/latest-pruned-offsets", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Sec-WebSocket-Protocol", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetLatestPrunedOffsetsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetLatestPrunedOffsetsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetV2StateLatestPrunedOffsetsError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get ledger end
pub async fn get_v2_state_ledger_end(
    configuration: &configuration::Configuration,
) -> Result<models::GetLedgerEndResponse, Error<GetV2StateLedgerEndError>> {
    let uri_str = format!("{}/v2/state/ledger-end", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Sec-WebSocket-Protocol", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetLedgerEndResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetLedgerEndResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetV2StateLedgerEndError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get transaction tree by  id
pub async fn get_v2_updates_transaction_tree_by_id_update_id(
    configuration: &configuration::Configuration,
    update_id: &str,
    parties: Option<Vec<String>>,
) -> Result<models::JsGetTransactionTreeResponse, Error<GetV2UpdatesTransactionTreeByIdUpdateIdError>>
{
    // add a prefix to parameters to efficiently prevent name collisions
    let p_update_id = update_id;
    let p_parties = parties;

    let uri_str = format!(
        "{}/v2/updates/transaction-tree-by-id/{update_id}",
        configuration.base_path,
        update_id = crate::apis::urlencode(p_update_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_parties {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("parties".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "parties",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Sec-WebSocket-Protocol", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::JsGetTransactionTreeResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::JsGetTransactionTreeResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetV2UpdatesTransactionTreeByIdUpdateIdError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get transaction tree by offset
pub async fn get_v2_updates_transaction_tree_by_offset_offset(
    configuration: &configuration::Configuration,
    offset: i64,
    parties: Option<Vec<String>>,
) -> Result<
    models::JsGetTransactionTreeResponse,
    Error<GetV2UpdatesTransactionTreeByOffsetOffsetError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_offset = offset;
    let p_parties = parties;

    let uri_str = format!(
        "{}/v2/updates/transaction-tree-by-offset/{offset}",
        configuration.base_path,
        offset = p_offset
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_parties {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("parties".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "parties",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Sec-WebSocket-Protocol", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::JsGetTransactionTreeResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::JsGetTransactionTreeResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetV2UpdatesTransactionTreeByOffsetOffsetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// List all users.
pub async fn get_v2_users(
    configuration: &configuration::Configuration,
    page_size: Option<i32>,
    page_token: Option<&str>,
) -> Result<models::ListUsersResponse, Error<GetV2UsersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_page_size = page_size;
    let p_page_token = page_token;

    let uri_str = format!("{}/v2/users", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page_size {
        req_builder = req_builder.query(&[("pageSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page_token {
        req_builder = req_builder.query(&[("pageToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Sec-WebSocket-Protocol", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListUsersResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListUsersResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetV2UsersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get user details.
pub async fn get_v2_users_user_id(
    configuration: &configuration::Configuration,
    user_id: &str,
) -> Result<models::GetUserResponse, Error<GetV2UsersUserIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_user_id = user_id;

    let uri_str = format!(
        "{}/v2/users/{user_id}",
        configuration.base_path,
        user_id = crate::apis::urlencode(p_user_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Sec-WebSocket-Protocol", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetUserResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetUserResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetV2UsersUserIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// List user rights.
pub async fn get_v2_users_user_id_rights(
    configuration: &configuration::Configuration,
    user_id: &str,
) -> Result<models::ListUserRightsResponse, Error<GetV2UsersUserIdRightsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_user_id = user_id;

    let uri_str = format!(
        "{}/v2/users/{user_id}/rights",
        configuration.base_path,
        user_id = crate::apis::urlencode(p_user_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Sec-WebSocket-Protocol", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListUserRightsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListUserRightsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetV2UsersUserIdRightsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get the version details of the participant node
pub async fn get_v2_version(
    configuration: &configuration::Configuration,
) -> Result<models::GetLedgerApiVersionResponse, Error<GetV2VersionError>> {
    let uri_str = format!("{}/v2/version", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Sec-WebSocket-Protocol", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetLedgerApiVersionResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetLedgerApiVersionResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetV2VersionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Update identity provider config
pub async fn patch_v2_idps_idp_id(
    configuration: &configuration::Configuration,
    idp_id: &str,
    update_identity_provider_config_request: models::UpdateIdentityProviderConfigRequest,
) -> Result<models::UpdateIdentityProviderConfigResponse, Error<PatchV2IdpsIdpIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_idp_id = idp_id;
    let p_update_identity_provider_config_request = update_identity_provider_config_request;

    let uri_str = format!(
        "{}/v2/idps/{idp_id}",
        configuration.base_path,
        idp_id = crate::apis::urlencode(p_idp_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Sec-WebSocket-Protocol", value);
    };
    req_builder = req_builder.json(&p_update_identity_provider_config_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UpdateIdentityProviderConfigResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UpdateIdentityProviderConfigResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PatchV2IdpsIdpIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Allocate a new party to the participant node
pub async fn patch_v2_parties_party(
    configuration: &configuration::Configuration,
    party: &str,
    update_party_details_request: models::UpdatePartyDetailsRequest,
) -> Result<models::UpdatePartyDetailsResponse, Error<PatchV2PartiesPartyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_party = party;
    let p_update_party_details_request = update_party_details_request;

    let uri_str = format!(
        "{}/v2/parties/{party}",
        configuration.base_path,
        party = crate::apis::urlencode(p_party)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Sec-WebSocket-Protocol", value);
    };
    req_builder = req_builder.json(&p_update_party_details_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UpdatePartyDetailsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UpdatePartyDetailsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PatchV2PartiesPartyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Update  user.
pub async fn patch_v2_users_user_id(
    configuration: &configuration::Configuration,
    user_id: &str,
    update_user_request: models::UpdateUserRequest,
) -> Result<models::UpdateUserResponse, Error<PatchV2UsersUserIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_user_id = user_id;
    let p_update_user_request = update_user_request;

    let uri_str = format!(
        "{}/v2/users/{user_id}",
        configuration.base_path,
        user_id = crate::apis::urlencode(p_user_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Sec-WebSocket-Protocol", value);
    };
    req_builder = req_builder.json(&p_update_user_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UpdateUserResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UpdateUserResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PatchV2UsersUserIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Update user identity provider.
pub async fn patch_v2_users_user_id_identity_provider_id(
    configuration: &configuration::Configuration,
    user_id: &str,
    update_user_identity_provider_id_request: models::UpdateUserIdentityProviderIdRequest,
) -> Result<serde_json::Value, Error<PatchV2UsersUserIdIdentityProviderIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_user_id = user_id;
    let p_update_user_identity_provider_id_request = update_user_identity_provider_id_request;

    let uri_str = format!(
        "{}/v2/users/{user_id}/identity-provider-id",
        configuration.base_path,
        user_id = crate::apis::urlencode(p_user_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Sec-WebSocket-Protocol", value);
    };
    req_builder = req_builder.json(&p_update_user_identity_provider_id_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PatchV2UsersUserIdIdentityProviderIdError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Revoke user rights.
pub async fn patch_v2_users_user_id_rights(
    configuration: &configuration::Configuration,
    user_id: &str,
    revoke_user_rights_request: models::RevokeUserRightsRequest,
) -> Result<models::RevokeUserRightsResponse, Error<PatchV2UsersUserIdRightsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_user_id = user_id;
    let p_revoke_user_rights_request = revoke_user_rights_request;

    let uri_str = format!(
        "{}/v2/users/{user_id}/rights",
        configuration.base_path,
        user_id = crate::apis::urlencode(p_user_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Sec-WebSocket-Protocol", value);
    };
    req_builder = req_builder.json(&p_revoke_user_rights_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RevokeUserRightsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RevokeUserRightsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PatchV2UsersUserIdRightsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Submit a command asynchronously
pub async fn post_v2_commands_async_submit(
    configuration: &configuration::Configuration,
    js_commands: models::JsCommands,
) -> Result<serde_json::Value, Error<PostV2CommandsAsyncSubmitError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_js_commands = js_commands;

    let uri_str = format!("{}/v2/commands/async/submit", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Sec-WebSocket-Protocol", value);
    };
    req_builder = req_builder.json(&p_js_commands);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostV2CommandsAsyncSubmitError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Submit reassignment command asynchronously
pub async fn post_v2_commands_async_submit_reassignment(
    configuration: &configuration::Configuration,
    submit_reassignment_request: models::SubmitReassignmentRequest,
) -> Result<serde_json::Value, Error<PostV2CommandsAsyncSubmitReassignmentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_submit_reassignment_request = submit_reassignment_request;

    let uri_str = format!(
        "{}/v2/commands/async/submit-reassignment",
        configuration.base_path
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Sec-WebSocket-Protocol", value);
    };
    req_builder = req_builder.json(&p_submit_reassignment_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostV2CommandsAsyncSubmitReassignmentError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Query completions list (blocking call)
pub async fn post_v2_commands_completions(
    configuration: &configuration::Configuration,
    completion_stream_request: models::CompletionStreamRequest,
    limit: Option<i64>,
    stream_idle_timeout_ms: Option<i64>,
) -> Result<Vec<models::CompletionStreamResponse>, Error<PostV2CommandsCompletionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_completion_stream_request = completion_stream_request;
    let p_limit = limit;
    let p_stream_idle_timeout_ms = stream_idle_timeout_ms;

    let uri_str = format!("{}/v2/commands/completions", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_stream_idle_timeout_ms {
        req_builder = req_builder.query(&[("stream_idle_timeout_ms", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Sec-WebSocket-Protocol", value);
    };
    req_builder = req_builder.json(&p_completion_stream_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::CompletionStreamResponse&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::CompletionStreamResponse&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostV2CommandsCompletionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Submit a batch of commands and wait for the completion details
pub async fn post_v2_commands_submit_and_wait(
    configuration: &configuration::Configuration,
    js_commands: models::JsCommands,
) -> Result<models::SubmitAndWaitResponse, Error<PostV2CommandsSubmitAndWaitError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_js_commands = js_commands;

    let uri_str = format!("{}/v2/commands/submit-and-wait", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Sec-WebSocket-Protocol", value);
    };
    req_builder = req_builder.json(&p_js_commands);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SubmitAndWaitResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SubmitAndWaitResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostV2CommandsSubmitAndWaitError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Submit a batch of reassignment commands and wait for the reassignment response
pub async fn post_v2_commands_submit_and_wait_for_reassignment(
    configuration: &configuration::Configuration,
    submit_and_wait_for_reassignment_request: models::SubmitAndWaitForReassignmentRequest,
) -> Result<
    models::JsSubmitAndWaitForReassignmentResponse,
    Error<PostV2CommandsSubmitAndWaitForReassignmentError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_submit_and_wait_for_reassignment_request = submit_and_wait_for_reassignment_request;

    let uri_str = format!(
        "{}/v2/commands/submit-and-wait-for-reassignment",
        configuration.base_path
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Sec-WebSocket-Protocol", value);
    };
    req_builder = req_builder.json(&p_submit_and_wait_for_reassignment_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::JsSubmitAndWaitForReassignmentResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::JsSubmitAndWaitForReassignmentResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostV2CommandsSubmitAndWaitForReassignmentError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Submit a batch of commands and wait for the transaction response
pub async fn post_v2_commands_submit_and_wait_for_transaction(
    configuration: &configuration::Configuration,
    js_submit_and_wait_for_transaction_request: models::JsSubmitAndWaitForTransactionRequest,
) -> Result<
    models::JsSubmitAndWaitForTransactionResponse,
    Error<PostV2CommandsSubmitAndWaitForTransactionError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_js_submit_and_wait_for_transaction_request = js_submit_and_wait_for_transaction_request;

    let uri_str = format!(
        "{}/v2/commands/submit-and-wait-for-transaction",
        configuration.base_path
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Sec-WebSocket-Protocol", value);
    };
    req_builder = req_builder.json(&p_js_submit_and_wait_for_transaction_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::JsSubmitAndWaitForTransactionResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::JsSubmitAndWaitForTransactionResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostV2CommandsSubmitAndWaitForTransactionError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Submit a batch of commands and wait for the transaction trees response
pub async fn post_v2_commands_submit_and_wait_for_transaction_tree(
    configuration: &configuration::Configuration,
    js_commands: models::JsCommands,
) -> Result<
    models::JsSubmitAndWaitForTransactionTreeResponse,
    Error<PostV2CommandsSubmitAndWaitForTransactionTreeError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_js_commands = js_commands;

    let uri_str = format!(
        "{}/v2/commands/submit-and-wait-for-transaction-tree",
        configuration.base_path
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Sec-WebSocket-Protocol", value);
    };
    req_builder = req_builder.json(&p_js_commands);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::JsSubmitAndWaitForTransactionTreeResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::JsSubmitAndWaitForTransactionTreeResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostV2CommandsSubmitAndWaitForTransactionTreeError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get events by contract Id
pub async fn post_v2_events_events_by_contract_id(
    configuration: &configuration::Configuration,
    get_events_by_contract_id_request: models::GetEventsByContractIdRequest,
) -> Result<models::JsGetEventsByContractIdResponse, Error<PostV2EventsEventsByContractIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_get_events_by_contract_id_request = get_events_by_contract_id_request;

    let uri_str = format!(
        "{}/v2/events/events-by-contract-id",
        configuration.base_path
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Sec-WebSocket-Protocol", value);
    };
    req_builder = req_builder.json(&p_get_events_by_contract_id_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::JsGetEventsByContractIdResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::JsGetEventsByContractIdResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostV2EventsEventsByContractIdError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Create identity provider configs
pub async fn post_v2_idps(
    configuration: &configuration::Configuration,
    create_identity_provider_config_request: models::CreateIdentityProviderConfigRequest,
) -> Result<models::CreateIdentityProviderConfigResponse, Error<PostV2IdpsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_create_identity_provider_config_request = create_identity_provider_config_request;

    let uri_str = format!("{}/v2/idps", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Sec-WebSocket-Protocol", value);
    };
    req_builder = req_builder.json(&p_create_identity_provider_config_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateIdentityProviderConfigResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateIdentityProviderConfigResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostV2IdpsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Execute a signed transaction
pub async fn post_v2_interactive_submission_execute(
    configuration: &configuration::Configuration,
    js_execute_submission_request: models::JsExecuteSubmissionRequest,
) -> Result<serde_json::Value, Error<PostV2InteractiveSubmissionExecuteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_js_execute_submission_request = js_execute_submission_request;

    let uri_str = format!(
        "{}/v2/interactive-submission/execute",
        configuration.base_path
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Sec-WebSocket-Protocol", value);
    };
    req_builder = req_builder.json(&p_js_execute_submission_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostV2InteractiveSubmissionExecuteError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Prepare commands for signing
pub async fn post_v2_interactive_submission_prepare(
    configuration: &configuration::Configuration,
    js_prepare_submission_request: models::JsPrepareSubmissionRequest,
) -> Result<models::JsPrepareSubmissionResponse, Error<PostV2InteractiveSubmissionPrepareError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_js_prepare_submission_request = js_prepare_submission_request;

    let uri_str = format!(
        "{}/v2/interactive-submission/prepare",
        configuration.base_path
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Sec-WebSocket-Protocol", value);
    };
    req_builder = req_builder.json(&p_js_prepare_submission_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::JsPrepareSubmissionResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::JsPrepareSubmissionResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostV2InteractiveSubmissionPrepareError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Upload a DAR to the participant node
pub async fn post_v2_packages(
    configuration: &configuration::Configuration,
    body: std::path::PathBuf,
) -> Result<serde_json::Value, Error<PostV2PackagesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body = body;

    let uri_str = format!("{}/v2/packages", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Sec-WebSocket-Protocol", value);
    };
    req_builder = req_builder.body(p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostV2PackagesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Allocate a new party to the participant node
pub async fn post_v2_parties(
    configuration: &configuration::Configuration,
    allocate_party_request: models::AllocatePartyRequest,
) -> Result<models::AllocatePartyResponse, Error<PostV2PartiesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_allocate_party_request = allocate_party_request;

    let uri_str = format!("{}/v2/parties", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Sec-WebSocket-Protocol", value);
    };
    req_builder = req_builder.json(&p_allocate_party_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AllocatePartyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AllocatePartyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostV2PartiesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Query active contracts list (blocking call)
pub async fn post_v2_state_active_contracts(
    configuration: &configuration::Configuration,
    get_active_contracts_request: models::GetActiveContractsRequest,
    limit: Option<i64>,
    stream_idle_timeout_ms: Option<i64>,
) -> Result<Vec<models::JsGetActiveContractsResponse>, Error<PostV2StateActiveContractsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_get_active_contracts_request = get_active_contracts_request;
    let p_limit = limit;
    let p_stream_idle_timeout_ms = stream_idle_timeout_ms;

    let uri_str = format!("{}/v2/state/active-contracts", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_stream_idle_timeout_ms {
        req_builder = req_builder.query(&[("stream_idle_timeout_ms", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Sec-WebSocket-Protocol", value);
    };
    req_builder = req_builder.json(&p_get_active_contracts_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::JsGetActiveContractsResponse&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::JsGetActiveContractsResponse&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostV2StateActiveContractsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Query flat transactions update list (blocking call)
pub async fn post_v2_updates_flats(
    configuration: &configuration::Configuration,
    get_updates_request: models::GetUpdatesRequest,
    limit: Option<i64>,
    stream_idle_timeout_ms: Option<i64>,
) -> Result<Vec<models::JsGetUpdatesResponse>, Error<PostV2UpdatesFlatsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_get_updates_request = get_updates_request;
    let p_limit = limit;
    let p_stream_idle_timeout_ms = stream_idle_timeout_ms;

    let uri_str = format!("{}/v2/updates/flats", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_stream_idle_timeout_ms {
        req_builder = req_builder.query(&[("stream_idle_timeout_ms", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Sec-WebSocket-Protocol", value);
    };
    req_builder = req_builder.json(&p_get_updates_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::JsGetUpdatesResponse&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::JsGetUpdatesResponse&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostV2UpdatesFlatsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get transaction by id
pub async fn post_v2_updates_transaction_by_id(
    configuration: &configuration::Configuration,
    get_transaction_by_id_request: models::GetTransactionByIdRequest,
) -> Result<models::JsGetTransactionResponse, Error<PostV2UpdatesTransactionByIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_get_transaction_by_id_request = get_transaction_by_id_request;

    let uri_str = format!("{}/v2/updates/transaction-by-id", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Sec-WebSocket-Protocol", value);
    };
    req_builder = req_builder.json(&p_get_transaction_by_id_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::JsGetTransactionResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::JsGetTransactionResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostV2UpdatesTransactionByIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get transaction by offset
pub async fn post_v2_updates_transaction_by_offset(
    configuration: &configuration::Configuration,
    get_transaction_by_offset_request: models::GetTransactionByOffsetRequest,
) -> Result<models::JsGetTransactionResponse, Error<PostV2UpdatesTransactionByOffsetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_get_transaction_by_offset_request = get_transaction_by_offset_request;

    let uri_str = format!(
        "{}/v2/updates/transaction-by-offset",
        configuration.base_path
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Sec-WebSocket-Protocol", value);
    };
    req_builder = req_builder.json(&p_get_transaction_by_offset_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::JsGetTransactionResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::JsGetTransactionResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostV2UpdatesTransactionByOffsetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Query update transactions tree list (blocking call)
pub async fn post_v2_updates_trees(
    configuration: &configuration::Configuration,
    get_updates_request: models::GetUpdatesRequest,
    limit: Option<i64>,
    stream_idle_timeout_ms: Option<i64>,
) -> Result<Vec<models::JsGetUpdateTreesResponse>, Error<PostV2UpdatesTreesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_get_updates_request = get_updates_request;
    let p_limit = limit;
    let p_stream_idle_timeout_ms = stream_idle_timeout_ms;

    let uri_str = format!("{}/v2/updates/trees", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_stream_idle_timeout_ms {
        req_builder = req_builder.query(&[("stream_idle_timeout_ms", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Sec-WebSocket-Protocol", value);
    };
    req_builder = req_builder.json(&p_get_updates_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::JsGetUpdateTreesResponse&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::JsGetUpdateTreesResponse&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostV2UpdatesTreesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get update by id
pub async fn post_v2_updates_update_by_id(
    configuration: &configuration::Configuration,
    get_update_by_id_request: models::GetUpdateByIdRequest,
) -> Result<models::JsGetUpdateResponse, Error<PostV2UpdatesUpdateByIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_get_update_by_id_request = get_update_by_id_request;

    let uri_str = format!("{}/v2/updates/update-by-id", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Sec-WebSocket-Protocol", value);
    };
    req_builder = req_builder.json(&p_get_update_by_id_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::JsGetUpdateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::JsGetUpdateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostV2UpdatesUpdateByIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get update by offset
pub async fn post_v2_updates_update_by_offset(
    configuration: &configuration::Configuration,
    get_update_by_offset_request: models::GetUpdateByOffsetRequest,
) -> Result<models::JsGetUpdateResponse, Error<PostV2UpdatesUpdateByOffsetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_get_update_by_offset_request = get_update_by_offset_request;

    let uri_str = format!("{}/v2/updates/update-by-offset", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Sec-WebSocket-Protocol", value);
    };
    req_builder = req_builder.json(&p_get_update_by_offset_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::JsGetUpdateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::JsGetUpdateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostV2UpdatesUpdateByOffsetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Create user.
pub async fn post_v2_users(
    configuration: &configuration::Configuration,
    create_user_request: models::CreateUserRequest,
) -> Result<models::CreateUserResponse, Error<PostV2UsersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_create_user_request = create_user_request;

    let uri_str = format!("{}/v2/users", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Sec-WebSocket-Protocol", value);
    };
    req_builder = req_builder.json(&p_create_user_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateUserResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateUserResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostV2UsersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Grant user rights.
pub async fn post_v2_users_user_id_rights(
    configuration: &configuration::Configuration,
    user_id: &str,
    grant_user_rights_request: models::GrantUserRightsRequest,
) -> Result<models::GrantUserRightsResponse, Error<PostV2UsersUserIdRightsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_user_id = user_id;
    let p_grant_user_rights_request = grant_user_rights_request;

    let uri_str = format!(
        "{}/v2/users/{user_id}/rights",
        configuration.base_path,
        user_id = crate::apis::urlencode(p_user_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Sec-WebSocket-Protocol", value);
    };
    req_builder = req_builder.json(&p_grant_user_rights_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GrantUserRightsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GrantUserRightsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostV2UsersUserIdRightsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
