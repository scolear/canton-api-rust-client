/*
 * JSON Ledger API HTTP endpoints
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.3.0-SNAPSHOT
 * 
 * Generated by: https://openapi-generator.tech
 */

use crate::models;
use serde::{Deserialize, Serialize};

/// JsCommands : A composite command that groups multiple commands together.
#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct JsCommands {
    /// Individual elements of this atomic command. Must be non-empty. Required
    #[serde(rename = "commands", skip_serializing_if = "Option::is_none")]
    pub commands: Option<Vec<models::Command>>,
    /// Uniquely identifies the command. The triple (user_id, act_as, command_id) constitutes the change ID for the intended ledger change, where act_as is interpreted as a set of party names. The change ID can be used for matching the intended ledger changes with all their completions. Must be a valid LedgerString (as described in ``value.proto``). Required
    #[serde(rename = "commandId")]
    pub command_id: String,
    /// Set of parties on whose behalf the command should be executed. If ledger API authorization is enabled, then the authorization metadata must authorize the sender of the request to act on behalf of each of the given parties. Each element must be a valid PartyIdString (as described in ``value.proto``). Required, must be non-empty.
    #[serde(rename = "actAs", skip_serializing_if = "Option::is_none")]
    pub act_as: Option<Vec<String>>,
    /// Uniquely identifies the participant user that issued the command. Must be a valid UserIdString (as described in ``value.proto``). Required unless authentication is used with a user token. In that case, the token's user-id will be used for the request's user_id.
    #[serde(rename = "userId", skip_serializing_if = "Option::is_none")]
    pub user_id: Option<String>,
    /// Set of parties on whose behalf (in addition to all parties listed in ``act_as``) contracts can be retrieved. This affects Daml operations such as ``fetch``, ``fetchByKey``, ``lookupByKey``, ``exercise``, and ``exerciseByKey``. Note: A participant node of a Daml network can host multiple parties. Each contract present on the participant node is only visible to a subset of these parties. A command can only use contracts that are visible to at least one of the parties in ``act_as`` or ``read_as``. This visibility check is independent from the Daml authorization rules for fetch operations. If ledger API authorization is enabled, then the authorization metadata must authorize the sender of the request to read contract data on behalf of each of the given parties. Optional
    #[serde(rename = "readAs", skip_serializing_if = "Option::is_none")]
    pub read_as: Option<Vec<String>>,
    /// Identifier of the on-ledger workflow that this command is a part of. Must be a valid LedgerString (as described in ``value.proto``). Optional
    #[serde(rename = "workflowId", skip_serializing_if = "Option::is_none")]
    pub workflow_id: Option<String>,
    #[serde(rename = "deduplicationPeriod", skip_serializing_if = "Option::is_none")]
    pub deduplication_period: Option<Box<models::DeduplicationPeriod>>,
    /// Lower bound for the ledger time assigned to the resulting transaction. Note: The ledger time of a transaction is assigned as part of command interpretation. Use this property if you expect that command interpretation will take a considerate amount of time, such that by the time the resulting transaction is sequenced, its assigned ledger time is not valid anymore. Must not be set at the same time as min_ledger_time_rel. Optional
    #[serde(rename = "minLedgerTimeAbs", skip_serializing_if = "Option::is_none")]
    pub min_ledger_time_abs: Option<String>,
    #[serde(rename = "minLedgerTimeRel", skip_serializing_if = "Option::is_none")]
    pub min_ledger_time_rel: Option<Box<models::Duration>>,
    /// A unique identifier to distinguish completions for different submissions with the same change ID. Typically a random UUID. Applications are expected to use a different UUID for each retry of a submission with the same change ID. Must be a valid LedgerString (as described in ``value.proto``).  If omitted, the participant or the committer may set a value of their choice. Optional
    #[serde(rename = "submissionId", skip_serializing_if = "Option::is_none")]
    pub submission_id: Option<String>,
    /// Additional contracts used to resolve contract & contract key lookups. Optional
    #[serde(rename = "disclosedContracts", skip_serializing_if = "Option::is_none")]
    pub disclosed_contracts: Option<Vec<models::DisclosedContract>>,
    /// Must be a valid synchronizer id Optional
    #[serde(rename = "synchronizerId", skip_serializing_if = "Option::is_none")]
    pub synchronizer_id: Option<String>,
    /// The package-id selection preference of the client for resolving package names and interface instances in command submission and interpretation
    #[serde(rename = "packageIdSelectionPreference", skip_serializing_if = "Option::is_none")]
    pub package_id_selection_preference: Option<Vec<String>>,
}

impl JsCommands {
    /// A composite command that groups multiple commands together.
    pub fn new(command_id: String) -> JsCommands {
        JsCommands {
            commands: None,
            command_id,
            act_as: None,
            user_id: None,
            read_as: None,
            workflow_id: None,
            deduplication_period: None,
            min_ledger_time_abs: None,
            min_ledger_time_rel: None,
            submission_id: None,
            disclosed_contracts: None,
            synchronizer_id: None,
            package_id_selection_preference: None,
        }
    }
}

