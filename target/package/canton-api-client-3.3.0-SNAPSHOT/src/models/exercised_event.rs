/*
 * JSON Ledger API HTTP endpoints
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.3.0-SNAPSHOT
 * 
 * Generated by: https://openapi-generator.tech
 */

use crate::models;
use serde::{Deserialize, Serialize};

/// ExercisedEvent : Records that a choice has been exercised on a target contract.
#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct ExercisedEvent {
    /// The offset of origin. Offsets are managed by the participant nodes. Transactions can thus NOT be assumed to have the same offsets on different participant nodes. Required, it is a valid absolute offset (positive integer)
    #[serde(rename = "offset")]
    pub offset: i64,
    /// The position of this event in the originating transaction or reassignment. Node IDs are not necessarily equal across participants, as these may see different projections/parts of transactions. Required, must be valid node ID (non-negative integer)
    #[serde(rename = "nodeId")]
    pub node_id: i32,
    /// The ID of the target contract. Must be a valid LedgerString (as described in ``value.proto``). Required
    #[serde(rename = "contractId")]
    pub contract_id: String,
    /// The template of the target contract. The identifier uses the package-id reference format.  Required
    #[serde(rename = "templateId")]
    pub template_id: String,
    /// The interface where the choice is defined, if inherited. If defined, the identifier uses the package-id reference format.  Optional
    #[serde(rename = "interfaceId", skip_serializing_if = "Option::is_none")]
    pub interface_id: Option<String>,
    /// The choice that was exercised on the target contract. Must be a valid NameString (as described in ``value.proto``). Required
    #[serde(rename = "choice")]
    pub choice: String,
    /// The argument of the exercised choice. Required
    #[serde(rename = "choiceArgument", deserialize_with = "Option::deserialize")]
    pub choice_argument: Option<serde_json::Value>,
    /// The parties that exercised the choice. Each element must be a valid PartyIdString (as described in ``value.proto``). Required
    #[serde(rename = "actingParties", skip_serializing_if = "Option::is_none")]
    pub acting_parties: Option<Vec<String>>,
    /// If true, the target contract may no longer be exercised. Required
    #[serde(rename = "consuming")]
    pub consuming: bool,
    /// The parties that are notified of this event. The witnesses of an exercise node will depend on whether the exercise was consuming or not. If consuming, the witnesses are the union of the stakeholders and the actors. If not consuming, the witnesses are the union of the signatories and the actors. Note that the actors might not necessarily be observers and thus signatories. This is the case when the controllers of a choice are specified using \"flexible controllers\", using the ``choice ... controller`` syntax, and said controllers are not explicitly marked as observers. Each element must be a valid PartyIdString (as described in ``value.proto``). Required
    #[serde(rename = "witnessParties", skip_serializing_if = "Option::is_none")]
    pub witness_parties: Option<Vec<String>>,
    /// Specifies the upper boundary of the node ids of the events in the same transaction that appeared as a result of this ``ExercisedEvent``. This allows unambiguous identification of all the members of the subtree rooted at this node. A full subtree can be constructed when all descendant nodes are present in the stream. If nodes are heavily filtered, it is only possible to determine if a node is in a consequent subtree or not. Required
    #[serde(rename = "lastDescendantNodeId")]
    pub last_descendant_node_id: i32,
    /// The result of exercising the choice. Required
    #[serde(rename = "exerciseResult", deserialize_with = "Option::deserialize")]
    pub exercise_result: Option<serde_json::Value>,
    /// The package name of the contract. Required
    #[serde(rename = "packageName")]
    pub package_name: String,
    /// If the event is consuming, the interfaces implemented by the target template that have been matched from the interface filter query. Populated only in case interface filters with include_interface_view set.  The identifier uses the package-id reference format.  Optional
    #[serde(rename = "implementedInterfaces", skip_serializing_if = "Option::is_none")]
    pub implemented_interfaces: Option<Vec<String>>,
}

impl ExercisedEvent {
    /// Records that a choice has been exercised on a target contract.
    pub fn new(offset: i64, node_id: i32, contract_id: String, template_id: String, choice: String, choice_argument: Option<serde_json::Value>, consuming: bool, last_descendant_node_id: i32, exercise_result: Option<serde_json::Value>, package_name: String) -> ExercisedEvent {
        ExercisedEvent {
            offset,
            node_id,
            contract_id,
            template_id,
            interface_id: None,
            choice,
            choice_argument,
            acting_parties: None,
            consuming,
            witness_parties: None,
            last_descendant_node_id,
            exercise_result,
            package_name,
            implemented_interfaces: None,
        }
    }
}

